<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[concise notes]]></title>
  
  <link href="/blog/atom.xml" rel="self"/>
  <link href="https://vhf.github.io/blog/"/>
  <updated>2015-11-10T19:01:21.000Z</updated>
  <id>https://vhf.github.io/blog/</id>
  
  <author>
    <name><![CDATA[victor felder]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript performance with Babel and Node.js: a case against default parameters in tail call optimizations]]></title>
    <link href="https://vhf.github.io/blog/2015/11/02/javascript-performance-with-babel-and-node-js/"/>
    <id>https://vhf.github.io/blog/2015/11/02/javascript-performance-with-babel-and-node-js/</id>
    <published>2015-11-02T12:36:59.000Z</published>
    <updated>2015-11-10T19:01:21.000Z</updated>
    <content type="html"><![CDATA[<p>Disclaimer:</p>
<ul>
<li>Babel 5.8.29 (babel-core 5.8.33)</li>
<li>Node.js v5.0.0</li>
<li>I know these factorial examples are very artificial, please bear with me, I’ll explain how I came to look at those things at the end of this post</li>
<li>The title of this post might be incorrect (or too specific), I’ll also talk about it later</li>
<li>Optimization is not an obsession of mine. Having fun with JavaScript is.</li>
</ul>
<p>Here are three recursive implementations of the factorial function:</p>
<figure class="highlight js"><figcaption><span>tail-call.js</span><a href="https://gist.github.com/vhf/25eebd0aa0ca5b3c1aec#file-tail-call-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "naive"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * factorial1(x-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tail rec using a default parameter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec2(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec2</span>(<span class="params">x, acc = 1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> facRec2(x-<span class="number">1</span>, x*acc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tail rec</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec3(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec3</span>(<span class="params">x, acc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> facRec3(x-<span class="number">1</span>, x*acc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Which one do you think will perform better when transpiled into ES5, transformed by Babel’s tail call optimization (TCO for short), and run on Node.js (therefore V8)?</p>
<p>It would be reasonable to expect:</p>
<ul>
<li>#1 to be the slowest because there’s no tail call (therefore TCO does not happen)</li>
<li>#2 and #3 to perform better than #1 (because TCO)</li>
<li>#2 and #3 to be more or less equivalent in terms of performances</li>
</ul>
<p>Let’s <a href="https://github.com/bestiejs/benchmark.js" target="_blank" rel="external">benchmark</a> it (<a href="https://gist.github.com/vhf/ecd9dba814a4edd80680" target="_blank" rel="external">suite</a>): <code>babel tail-call.js &gt; tail-call-babel.js; node tail-call-babel.js</code></p>
<pre><code><span class="preprocessor">#<span class="number">1</span> no tail call          x <span class="number">1</span>,<span class="number">562</span>,<span class="number">075</span> ops/sec ±<span class="number">0.59</span>% (<span class="number">98</span> runs sampled)</span>
<span class="preprocessor">#<span class="number">2</span> TCO/default params    x   <span class="number">259</span>,<span class="number">399</span> ops/sec ±<span class="number">0.92</span>% (<span class="number">91</span> runs sampled)</span>
<span class="preprocessor">#<span class="number">3</span> TCO/no default params x <span class="number">7</span>,<span class="number">046</span>,<span class="number">389</span> ops/sec ±<span class="number">0.45</span>% (<span class="number">101</span> runs sampled)</span>
Fastest is <span class="preprocessor">#<span class="number">3</span> TCO/no default params</span>
</code></pre><ul>
<li>#3 is 27x (!) better than #2</li>
<li>Even #1 significantly outperforms #2</li>
</ul>
<p>So my quest began. What could be so wrong about #2?</p>
<p>The obvious thing to do at this point was to look at Babel’s output:</p>
<figure class="highlight js"><figcaption><span>tail-call-babel.js</span><a href="https://gist.github.com/vhf/d9e9750ae25e9dee6190#file-tail-call-babel-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="comment">// #1 "naive"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * factorial1(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 tail rec using a default parameter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec2(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec2</span>(<span class="params">_x2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> _again = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _function: <span class="keyword">while</span> (_again) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = _x2;</span><br><span class="line">    _again = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> acc = _arguments.length &lt;= <span class="number">1</span> || _arguments[<span class="number">1</span>] === <span class="literal">undefined</span> ? <span class="number">1</span> : _arguments[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _arguments = [_x2 = x - <span class="number">1</span>, x * acc];</span><br><span class="line">      _again = <span class="literal">true</span>;</span><br><span class="line">      acc = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">continue</span> _function;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 tail rec</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec3(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec3</span>(<span class="params">_x3, _x4</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _again2 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _function2: <span class="keyword">while</span> (_again2) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = _x3,</span><br><span class="line">        acc = _x4;</span><br><span class="line">    _again2 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _x3 = x - <span class="number">1</span>;</span><br><span class="line">      _x4 = x * acc;</span><br><span class="line">      _again2 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span> _function2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>My first reflex was to check if TCO happened. Yes, and it did a fine job at transforming both tail recursive functions <code>facRec2</code> and <code>facRec3</code> into iterative functions. (If <code>factorial2</code> uses an iterative <code>facRec2</code>, why would <code>factorial1</code> and its still-recursive implementation perform better? It’s nice to know that <code>factorial2</code> won’t bark <code>RangeError: Maximum call stack size exceeded</code> at me, but at what cost?)</p>
<p>The next obvious thing to do was to consider the only single little difference between <code>facRec2</code> and <code>facRec3</code> in the original code: the use of an ES6 default parameter. A quick glance at Babel’s output made the use of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external"><code>arguments</code></a> stand out.</p>
<p>I remembered reading about <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="external">V8 “optimization killers”</a>, particularly a bit about <code>arguments</code>. Let me summarize the third section in the form of a checklist with regards to how the transformed <code>facRec2</code> makes use of parameters and <code>arguments</code>:</p>
<ul>
<li>[ ] Don’t reassign defined parameters while also mentioning <code>arguments</code> in the body of a function</li>
<li>[x] Don’t leak <code>arguments</code></li>
<li>[x] Don’t assign to <code>arguments</code></li>
<li>[x] Don’t use <code>arguments</code> directly without <code>.length</code> or <code>[]</code></li>
<li>[x] Don’t <code>arguments[i]</code> with <code>i</code> not an integer or <code>i &gt; arguments.length-1</code></li>
<li>[x] Don’t do anything else than <code>fn.apply(y, arguments)</code></li>
</ul>
<p>Notice how <code>facRec2</code> does <code>_x2 = x - 1</code> although <code>_x2</code> is a defined parameter <em>and</em> <code>arguments</code> is mentioned in the function body? It contradicts the first rule.</p>
<p>I turned to V8. Here again, the awesome bluebird wiki page was very helpful: its first section, <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#1-tooling" target="_blank" rel="external">tooling</a>, had been my reference for some time.</p>
<p>I added:</p>
<figure class="highlight js"><figcaption><span>tail-call-babel-v8.js</span><a href="https://gist.github.com/vhf/01c095e09accf72108a1#file-tail-call-babel-v8-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printStatus</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = fn.name;</span><br><span class="line">  <span class="keyword">switch</span>(%GetOptimizationStatus(fn)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">console</span>.log(name, <span class="string">' is optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">console</span>.log(name, <span class="string">' is not optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">console</span>.log(name, <span class="string">' is always optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">console</span>.log(name, <span class="string">' is never optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">console</span>.log(name, <span class="string">' is maybe deoptimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial1(<span class="number">100</span>);</span><br><span class="line">factorial1(<span class="number">100</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(factorial1);</span><br><span class="line">factorial1(<span class="number">100</span>);</span><br><span class="line">printStatus(factorial1);</span><br><span class="line"></span><br><span class="line">facRec2(<span class="number">100</span>, <span class="number">1</span>); <span class="comment">// I should add that facRec2(100) leads to the same perf issue</span></span><br><span class="line">facRec2(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(facRec2);</span><br><span class="line">facRec2(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">printStatus(facRec2);</span><br><span class="line"></span><br><span class="line">facRec3(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">facRec3(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(facRec3);</span><br><span class="line">facRec3(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">printStatus(facRec3);</span><br></pre></td></tr></table></figure>
<p>at the end of <code>tail-call-babel.js</code> and ran the following:</p>
<pre><code>node <span class="comment">--allow-natives-syntax tail-call-babel.js</span>
  factorial1 <span class="keyword">is</span> optimized
  facRec2 <span class="keyword">is</span> <span class="keyword">not</span> optimized
  facRec3 <span class="keyword">is</span> optimized
</code></pre><p>It was clear that V8 — more precisely <a href="http://jayconrod.com/posts/54/a-tour-of-v8-crankshaft-the-optimizing-compiler" target="_blank" rel="external">Crankshaft</a> — was bailing out on <code>facRec2</code>.</p>
<p>I simply had to refactor <code>facRec2</code> to make it stop reassigning to <code>_x2</code>, right? Nope, <code>facRec2</code> still could not be optimized. Here’s a <a href="https://gist.github.com/vhf/5560a6502d5147a766f6" target="_blank" rel="external">gist</a>.</p>
<p>Going back to the checklist, I noticed that <code>facRec2</code> actually assigns to the <code>_arguments</code> object, which is a reference to <code>arguments</code>, which also contradicts something from the above checklist: Don’t assign to <code>arguments</code>.</p>
<p>Going back to the <code>facRec2</code> generated code, I copied it to create <code>facRec2b</code>, replacing <code>var _arguments = arguments;</code> with <code>var $_len = arguments.length; var _arguments = new Array($_len); for(var $_i = 0; $_i &lt; $_len; ++$_i) {_arguments[$_i] = arguments[$_i];}</code> (<a href="https://gist.github.com/vhf/58769c1d0462094a66a3" target="_blank" rel="external">full gist</a>). And V8 was happy: <code>facRec2b is optimized</code>.</p>
<p>New benchmark:</p>
<pre><code><span class="preprocessor">#<span class="number">1</span> no tail call               x <span class="number">1</span>,<span class="number">562</span>,<span class="number">300</span> ops/sec ±<span class="number">0.44</span>% (<span class="number">98</span> runs sampled)</span>
<span class="preprocessor">#<span class="number">2</span> TCO/default params + leak  x   <span class="number">256</span>,<span class="number">521</span> ops/sec ±<span class="number">0.96</span>% (<span class="number">95</span> runs sampled)</span>
<span class="preprocessor">#<span class="number">2</span> TCO/default params no leak x   <span class="number">812</span>,<span class="number">920</span> ops/sec ±<span class="number">0.83</span>% (<span class="number">94</span> runs sampled)</span>
<span class="preprocessor">#<span class="number">3</span> TCO/no default params      x <span class="number">7</span>,<span class="number">060</span>,<span class="number">279</span> ops/sec ±<span class="number">0.49</span>% (<span class="number">94</span> runs sampled)</span>
</code></pre><p>When optimized by V8, <code>facRec2b</code> runs already 3x faster than its <code>facRec2</code> counterpart, but still ~2x slower than <code>factorial1</code>, and their performances cannot be matched with <code>facRec3</code>.</p>
<p>Here were my initial conclusions:</p>
<ul>
<li>assigning to <code>_arguments</code>, which references <code>arguments</code>, is what prevents V8 from optimizing <code>facRec2</code></li>
<li>safely converting <code>arguments</code> to an array fixes this issue</li>
<li>even with this fix, <code>facRec2b</code> is still so slow that we should simply decide not to use default parameters in any function susceptible to be TCOed by Babel</li>
<li>is there a better way to get V8 to optimize <code>facRec2</code>?</li>
<li>what’s up with this <em>Don’t reassign defined parameters while also mentioning <code>arguments</code> in the body of a function</em> rule? I thought <a href="https://gist.github.com/vhf/a884c556a70bdcf21fbc" target="_blank" rel="external">this</a> would trigger an <em>Assignment to parameter in arguments object</em> but I could not make it happen. Answer at the end of this post.</li>
</ul>
<p>Was there more to it?</p>
<p>I took a closer look:</p>
<pre><code>node --trace-opt --trace_deopt --allow-natives-syntax tail-call-babel.js | grep facRec2 | grep -v facRec2b
  [compiling <span class="function"><span class="keyword">method</span> 0<span class="title">x11469d0922c1</span> &lt;<span class="title">JS</span> <span class="title">Function</span> <span class="title">facRec2</span> <span class="params">(SharedFunctionInfo 0x24a5614171a9)</span>&gt; <span class="title">using</span> <span class="title">Crankshaft</span>]
  [<span class="title">aborted</span> <span class="title">optimizing</span> 0<span class="title">x11469d0922c1</span> &lt;<span class="title">JS</span> <span class="title">Function</span> <span class="title">facRec2</span> <span class="params">(SharedFunctionInfo 0x24a5614171a9)</span>&gt; <span class="title">because</span>:</span> Unsupported phi use <span class="keyword">of</span> arguments]
  [disabled optimization <span class="keyword">for</span> <span class="number">0</span>x24a5614171a9 &lt;SharedFunctionInfo facRec2&gt;, reason: Unsupported phi use <span class="keyword">of</span> arguments]
</code></pre><p>Unsupported phi use of arguments. At this point I should probably say that I don’t know much about V8 internals or source code. However, I was still determined to know what was wrong with <code>facRec2</code>, so I tried looking for this cryptic <code>Unsupported phi use of arguments</code> thing on Google (after all, they are the most qualified for this particular request).</p>
<p>It’s not every day that one of my search engine requests only returns 11 results. The most interesting one is probably <a href="https://codereview.chromium.org/7553006" target="_blank" rel="external">the very commit that introduced this bailout reason</a>. I took a quick glance at <code>HGraph::CheckPhis</code>: something about blocks?</p>
<p>I thought I would learn more trying to write a minimal program reproducing this bailout reason. But that was not an easy task. What I ended up with are these three functions:</p>
<figure class="highlight js"><figcaption><span>unsupported-phi-use-of-arguments.js</span><a href="https://gist.github.com/vhf/5f88c10e2a0680a4fb19#file-unsupported-phi-use-of-arguments-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> === <span class="number">0</span>) &#123; <span class="comment">// anything evaluating to true, except a number or `true`</span></span><br><span class="line">    _arguments = [<span class="number">0</span>]; <span class="comment">// Unsupported phi use of arguments</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    _arguments = [<span class="number">0</span>]; <span class="comment">// Unsupported phi use of arguments</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> again = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (again) &#123;</span><br><span class="line">    _arguments = [<span class="number">0</span>]; <span class="comment">// Unsupported phi use of arguments</span></span><br><span class="line">    again = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HGraph::CheckPhis</code> started to make sense: reassigning <code>arguments</code> inside a “block” triggers <em>Unsupported phi use of arguments</em>. But assigning <em>to</em> <code>arguments</code> does not: it triggers a <em>Bad value context for arguments value</em>, which is already covered on <a href="http://bahmutov.calepin.co/detecting-function-optimizations-in-v8.html" target="_blank" rel="external">blogs</a> and <a href="http://stackoverflow.com/questions/29198195/whats-the-deal-with-optimising-arguments" target="_blank" rel="external">StackOverflow</a>.</p>
<h3 id="So,_what’s_your_point?_Conclusion-">So, what’s your point? Conclusion.</h3><p>I just wanted to practice my storytelling. And also, I wanted to raise this question: what can we do about this whole default-parameter-TCO-V8-thing? I’m not sure, so here are a few questions I would like to ask you:</p>
<ul>
<li>Should we just avoid using default parameters in any function susceptible to be TCOed by Babel? (in this example, x27 on V8)</li>
<li>or make Babel safely create an array from <code>arguments</code> in such cases? (x3)</li>
<li>or at least mention this thing in Babel’s doc as soon as Babel 6 unblacklists <code>es6.tailCall</code>? (If this ever happens? If you have informations about this blacklisting, I’d love to know!)</li>
</ul>
<p><strong>I’d love to get your opinion on these questions!</strong></p>
<p>In a very interesting <a href="https://devchat.tv/js-jabber/171-jsj-babel-with-sebastian-mckenzie" target="_blank" rel="external">recent podcast</a> ([<a href="http://devchat.cachefly.net/javascriptjabber/transcript-171-jsj-babel-with-sebastian-mckenzie-js-jabber.pdf" target="_blank" rel="external">transcript</a>]), Babel’s author Sebastian McKenzie said several things about Babel’s performances, and how outputting more performant code impacts its readability, and how that’s ok because the focus is on performance: “would you care more about your code being pretty or your code being as fast as possible?”, and I agree, it is certainly more important for Babel to be fast than readable.</p>
<p>But he also said the following: “But now it’s just like you really shouldn’t be reading your compiled code anyway.” I have to disagree. In fact, if you indeed care about performances, you most probably <em>should</em> be reading your compiled code. (Now, don’t get met wrong: I think Babel is an awesome piece of software and I love it and I use it everywhere and Sebastian McKenzie et al. are doing a terrific job, and if you think this post is bashing Babel you’re just plain wrong. This disclaimer is probably useless, but I’m new to blogging and it’s kind of scary.)</p>
<p>I would love Babel to improve on this specific point; I can’t promise anything but I’ll try to hack on it. And if it gets me somewhere, I’ll try to write it up. My storytelling needs practice.</p>
<h4 id="Unsupported_phi_use_of_arguments">Unsupported phi use of arguments</h4><p>Unsatisfied of my poor understanding of this Crankshaft bailout message I reached out to <a href="http://mrale.ph" target="_blank" rel="external">Vyacheslav Egorov</a>, who first introduced it and promptly clarified he did not add the bailout itself.</p>
<p>I asked him what does <code>blocks_</code> contain in the <code>HGraph::CheckPhis</code> function I mentioned earlier:</p>
<blockquote>
<p>Blocks will contain CFG (control flow graph) blocks — these are not blocks in the syntactical sense, e.g. <code>x ? y : z</code> is not a block in JavaScript but will be 4 blocks in the CFG — once optimizing compiler gets to it.</p>
</blockquote>
<p>What’s up with this <em>Don’t reassign defined parameters while also mentioning <code>arguments</code> in the body of a function</em> rule? Why does <a href="https://gist.github.com/vhf/a884c556a70bdcf21fbc" target="_blank" rel="external">this code</a> not trigger a bailout?</p>
<blockquote>
<p>This limitation is still there — but it does not apply to strict functions. I think you somehow run your code in strict mode that’s why you don’t see a bailout.</p>
</blockquote>
<p>Indeed, I ran my tests in strict mode.</p>
<p>Regarding the second point of my conclusion, he said:</p>
<blockquote>
<p>Allocating array (and hope it will get handled by some optimization pass in the V8) is a bad idea.</p>
</blockquote>
<p>Thanks to Vyacheslav, this bailout message starts to make sense to me. He could have only answered the few questions I sent him by email. Instead, he was kind enough to answer them, read a draft of this blog post, and even went on to write a thorough and clear explaination of <em>Unsupported phi use of arguments</em> on his blog: <a href="http://mrale.ph/blog/2015/11/02/crankshaft-vs-arguments-object.html" target="_blank" rel="external">Crankshaft vs arguments object</a> — which I still need to digest.</p>
<h4 id="A_few_side_notes">A few side notes</h4><ul>
<li><a href="https://github.com/babel/babel/tree/v5.8.33/packages/babel/test/fixtures/transformation/es6.tail-call/recursion" target="_blank" rel="external">es6.tailCall recursion test case including default parameter</a>: Interesting test case with regards to V8 optimization: first because <code>_x2</code> (a defined parameter) gets reassigned which triggers <em>Assignment to parameter in arguments object</em> bailout reason, secondly because if we <code>var __x2 = _x2</code> and don’t reassign <code>_x2</code> we get the infamous <em>Unsupported phi use of arguments</em>.</li>
<li>Why the title of this post might be too specific: I have not investigated (yet?) whether <em>Unsupported phi use of arguments</em> is only triggered by Babel generated ES5 in the specific <em>TCO + default parameter</em> case or is also present in other Babel generated ES5 <em>default parameter</em> cases.</li>
<li>Why these artifical examples: because they are short and easy to reason about. Also, cf. the following point:</li>
<li>How did you come up with this thing? One of might projects depends on underscore, which does not have an equivalent of <a href="https://lodash.com/docs#get" target="_blank" rel="external"><code>get</code></a>. So I quickly drafted the tail rec <code>_.get</code> I was dreaming of, then googled for a bit and found John-David Dalton’s <a href="https://github.com/jashkenas/underscore/issues/2268#issuecomment-128731431" target="_blank" rel="external"><code>_.reduce(path, _.partial(_.result, _, _, void 0), object)</code></a> (which felt like too much black magic for me). But me being curious and it being a cold evening, I benchmarked both solutions. And mine was awfully slow. So I asked V8 about it, discovered the <em>phi</em> thing, reimplemented my recursive <code>get</code> without its default parameter, ran the benchmark again and got this: <code>TCO 676,411(±0.43%) | 674,426(±0.49%) JDD</code>. So, basically the same performances. Underscore never fails to impress me! Which led to two things: 1/ I kept my nice recursive <code>get</code> because it’s more readable, 2/ I spent my weekend researching+writing this blog post.</li>
<li>I know I should probably not rely on this benchmark package and should do cpu profiling instead, and that it’s easy to do with V8, etc. I think the timing differences shown here are big enough to decide that for this particular post, benchmark is good enough. But I’ll do better next time.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Babel might prevent some V8 optimizations to happen. Also, have you heard about Unsupported Phi Use of Arguments?]]>
    
    </summary>
    
      <category term="babel" scheme="https://vhf.github.io/blog/tags/babel/"/>
    
      <category term="es6" scheme="https://vhf.github.io/blog/tags/es6/"/>
    
      <category term="javascript" scheme="https://vhf.github.io/blog/tags/javascript/"/>
    
      <category term="nodejs" scheme="https://vhf.github.io/blog/tags/nodejs/"/>
    
      <category term="programming" scheme="https://vhf.github.io/blog/categories/programming/"/>
    
      <category term="JavaScript" scheme="https://vhf.github.io/blog/categories/programming/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 Destructuring]]></title>
    <link href="https://vhf.github.io/blog/2015/10/28/es6-destructuring/"/>
    <id>https://vhf.github.io/blog/2015/10/28/es6-destructuring/</id>
    <published>2015-10-28T14:29:42.000Z</published>
    <updated>2015-10-30T08:42:56.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>Destructuring works exactly as its syntax suggests</li>
<li>The only tricky point is object destructuring without variable declaration<ul>
<li>with declaration: <code>let {x: a} = {x: &#39;a&#39;};</code></li>
<li>without declaration: <code>({x: a} = {x: &#39;a&#39;});</code> (assuming that <code>a</code> has already been declared)</li>
<li>It’s symply because <a href="http://stackoverflow.com/questions/17382024/why-is-a-bare-array-valid-javascript-syntax-but-not-a-bare-object" target="_blank" rel="external">a bare object is not valid syntax</a></li>
</ul>
</li>
<li>Default arguments and destructuring:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prop === 'default' */</span> <span class="keyword">let</span> &#123;prop = <span class="string">'default'</span>&#125; = &#123;&#125;;</span><br><span class="line"><span class="comment">/* prop === 'value' */</span>   <span class="keyword">let</span> &#123;prop = <span class="string">'default'</span>&#125; = &#123;prop: <span class="string">'value'</span>&#125;;</span><br><span class="line"><span class="comment">/* name === 'value' */</span>   <span class="keyword">let</span> &#123;prop: name = <span class="string">'default'</span>&#125; = &#123;prop: <span class="string">'value'</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Default arguments also work for arrays:<ul>
<li><code>let [head = &quot;default&quot;] = [];</code></li>
</ul>
</li>
<li>Default values for destructuring assignment is especially useful as function arguments defaults:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> destructObject = (&#123;a = <span class="string">'a'</span>, b = <span class="string">'b'</span>&#125; = &#123;&#125;) =&gt; [a, b];</span><br><span class="line"><span class="keyword">let</span> destructObject = (&#123;a: arg1 = <span class="string">'a'</span>, b: arg2 = <span class="string">'b'</span>&#125; = &#123;&#125;) =&gt; [arg1, arg2];</span><br><span class="line">destructObject(&#123;&#125;);       <span class="comment">// ['a', 'b]</span></span><br><span class="line">destructObject(&#123;b: <span class="string">'c'</span>&#125;); <span class="comment">// ['a', 'c']</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[destructuring and assigning default values]]>
    
    </summary>
    
      <category term="es6" scheme="https://vhf.github.io/blog/tags/es6/"/>
    
      <category term="javascript" scheme="https://vhf.github.io/blog/tags/javascript/"/>
    
      <category term="programming" scheme="https://vhf.github.io/blog/categories/programming/"/>
    
      <category term="JavaScript" scheme="https://vhf.github.io/blog/categories/programming/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Promises]]></title>
    <link href="https://vhf.github.io/blog/2015/10/27/javascript-promises/"/>
    <id>https://vhf.github.io/blog/2015/10/27/javascript-promises/</id>
    <published>2015-10-27T18:37:41.000Z</published>
    <updated>2015-10-29T16:57:00.000Z</updated>
    <content type="html"><![CDATA[<p>I read <a href="https://60devs.com/best-practices-for-using-promises-in-js.html" target="_blank" rel="external">Best Practices for Using Promises in JS</a>. Here are some concise notes expanding on this topic.</p>
<ul>
<li>Let’s use bluebird as Promise implementation for node</li>
<li>Use <code>.then().catch()</code> instead of <code>.then(successCb, failCb)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = (shouldResolve) =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldResolve) &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject();</span><br><span class="line">  &#125;&#125;);</span><br><span class="line"></span><br><span class="line">promise(arg)</span><br><span class="line">  .then(() =&gt; &#123; <span class="comment">/* success */</span> &#125;)</span><br><span class="line">  .catch(ExceptionToCatch, OtherExceptionToCatch, (err) =&gt; &#123; <span class="comment">/* error */</span>&#125;)</span><br><span class="line">  .catch(StrangeExceptionToCatch, (err) =&gt; &#123; <span class="comment">/* error */</span>&#125;)</span><br><span class="line">  .catch((err) =&gt; &#123; <span class="comment">/* error */</span>&#125;); <span class="comment">// default</span></span><br></pre></td></tr></table></figure>
<p>To define an exception to catch:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCustomError</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyCustomError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line"></span><br><span class="line">promise(arg)</span><br><span class="line">  .then(() =&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> MyCustomError() &#125;)</span><br><span class="line">  .catch(MyCustomError, (err) =&gt; &#123;&#125;)</span><br><span class="line">  .catch((err) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Promise.all([promiseA(a), promiseB(b)])</code> runs two async functions in parallel, but <code>.then(() =&gt; {})</code> callback has no data result argument</li>
<li>Use <code>.spread</code> instead of <code>.then</code> to get this data: <code>.spread((dataA, dataB) =&gt; {})</code></li>
<li>To limit concurrency, <code>Promise.map([lotsOfStuff], promise, { concurrency: 3 }).then(() =&gt; {})</code></li>
<li>See also <code>.reduce</code> and <code>.filter</code></li>
<li>You can “pipe” your <code>.then</code> functions. If you do this, you should probably avoid using anonymous functions and enjoy more reusability, modularity, testability, readability</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readFile(data)</span><br><span class="line">  .then(<span class="built_in">JSON</span>.parse)</span><br><span class="line">  .then(treatStuff)</span><br><span class="line">  .catch(handleError)</span><br></pre></td></tr></table></figure>
<ul>
<li>Don’t abuse this thing. It’s nice to read, but it breaks the event loop and could introduce race conditions</li>
<li>A better approach is to pipe inside the <code>.then</code>:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readFile(data)</span><br><span class="line">  .then(pipe(<span class="built_in">JSON</span>.parse, treatStuff))</span><br><span class="line">  .catch(handleError)</span><br></pre></td></tr></table></figure>
<h2 id="Further_reading:">Further reading:</h2><ul>
<li><a href="http://bluebirdjs.com" target="_blank" rel="external">http://bluebirdjs.com</a></li>
<li><a href="https://promise-nuggets.github.io" target="_blank" rel="external">https://promise-nuggets.github.io</a></li>
<li><a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md" target="_blank" rel="external">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[promises, bluebird, etc]]>
    
    </summary>
    
      <category term="es6" scheme="https://vhf.github.io/blog/tags/es6/"/>
    
      <category term="javascript" scheme="https://vhf.github.io/blog/tags/javascript/"/>
    
      <category term="nodejs" scheme="https://vhf.github.io/blog/tags/nodejs/"/>
    
      <category term="promises" scheme="https://vhf.github.io/blog/tags/promises/"/>
    
      <category term="programming" scheme="https://vhf.github.io/blog/categories/programming/"/>
    
      <category term="JavaScript" scheme="https://vhf.github.io/blog/categories/programming/JavaScript/"/>
    
  </entry>
  
</feed>
