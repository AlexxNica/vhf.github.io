<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[concise notes]]></title>
  
  <link href="/blog/atom.xml" rel="self"/>
  <link href="https://vhf.github.io/blog/"/>
  <updated>2015-12-18T16:15:33.000Z</updated>
  <id>https://vhf.github.io/blog/</id>
  
  <author>
    <name><![CDATA[victor felder]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Making Babel fast with ES2015 rest parameters]]></title>
    <link href="https://vhf.github.io/blog/2015/12/17/making-babel-fast-with-rest-parameters/"/>
    <id>https://vhf.github.io/blog/2015/12/17/making-babel-fast-with-rest-parameters/</id>
    <published>2015-12-17T12:36:59.000Z</published>
    <updated>2015-12-18T16:15:33.000Z</updated>
    <content type="html"><![CDATA[<p>This post is a follow-up of <a href="http://vhf.github.io/blog/2015/11/02/javascript-performance-with-babel-and-node-js/">JavaScript performance with Babel and Node.js: a case against default parameters in tail call optimizations</a>. At the time, Babel 6 had only been published for a few hours.</p>
<p>When Babel 6 was released, I quickly realised that I kind of missed my target: tail call optimisation had been dropped in the process. But all was not lost, I could still investigate Babel’s use of <code>arguments</code>.</p>
<h1 id="Fixture_tests"><a href="#Fixture_tests" class="headerlink" title="Fixture tests"></a>Fixture tests</h1><p>First, I looked at a lot of fixture tests. These are files meant to test if a particular Babel transform or plug-in works properly. They consist of two files: <code>actual.js</code> (ES2015 code) and <code>expected.js</code>. The goal of this test is to check if the output of <code>babel actual.js</code> matches the content of <code>expected.js</code>.</p>
<p>I noticed something about a particular transform : <code>babel-plugin-transform-es2015-parameters</code>, more precisely about its handling of <code>rest</code> parameters:</p>
<figure class="highlight js"><figcaption><span>actual.js</span><a href="https://github.com/babel/babel/blob/82ddbc0ecd9a16fdb173bbcf85bc10ade6f9828d/packages/babel-plugin-transform-es2015-parameters/test/fixtures/parameters/rest-arrow-functions/actual.js" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> concat = (...arrs) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> x = arrs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> y = arrs[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>expected.js</span><a href="https://github.com/babel/babel/blob/82ddbc0ecd9a16fdb173bbcf85bc10ade6f9828d/packages/babel-plugin-transform-es2015-parameters/test/fixtures/parameters/rest-arrow-functions/expected.js" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> concat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This is unsafe. V8 will only be able to optimise the <code>concat</code> function if the <code>arguments</code> object has a length greater than 1. Otherwise, for example <code>concat([0])</code>, the attempt to access the undefined <code>arguments[1]</code> will force V8 to rematerialize <code>arguments</code> on the fly, preventing the whole function from being optimised.</p>
<h1 id="First_attempt"><a href="#First_attempt" class="headerlink" title="First attempt"></a>First attempt</h1><p>Having no idea about Babel’s codebase and internals, it took me a whole weekend to come up with a first patch: <a href="https://github.com/babel/babel/pull/2833" target="_blank" rel="external">#2833: Have es2015 rest transform safely use <code>arguments</code></a>. It fixed some of the rest-transformed unsafe use of <code>arguments</code> and it got merged after five weeks (which is way too long by the way, but I don’t blame anyone, I’m pretty sure it was an exceptional situation where someone said they would take care of this PR, then got busy, and in the meantime nobody saw the need to take over because someone was already in charge. No big deal).</p>
<p>At first I was pretty happy with this patch. The new <code>expected.js</code> looked like this:</p>
<figure class="highlight js"><figcaption><span>expected.js</span><a href="https://github.com/babel/babel/blob/9a97d92217dffcf6478611067c1525fa4004fce4/packages/babel-plugin-transform-es2015-parameters/test/fixtures/parameters/rest-arrow-functions/expected.js" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> concat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="built_in">arguments</span>.length &lt;= <span class="number">0</span> || <span class="built_in">arguments</span>[<span class="number">0</span>] === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">arguments</span>.length &lt;= <span class="number">1</span> || <span class="built_in">arguments</span>[<span class="number">1</span>] === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>which was safe. Some basic benchmarks were showing a 4x speedup. The tests were green. I had learned a lot about how Babel works.</p>
<p>Until <a href="https://github.com/babel/babel/pull/2833#discussion_r47472444" target="_blank" rel="external">someone noticed the pattern I was using was a bit weird</a>. In fact, the reason I initially chose this pattern was that I got it from <a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-es2015-parameters/src/default.js#L8-L11" target="_blank" rel="external">here</a>. While it makes sense to use it for default parameters handling (<code>ARGUMENTS.length &lt;= INDEX || ARGUMENTS[INDEX] === undefined ? DEFAULT_VALUE : ARGUMENTS[INDEX];</code>), it becomes overly complicated in the case where <code>DEFAULT_VALUE</code> is <code>undefined</code>.</p>
<h1 id="Second_attempt"><a href="#Second_attempt" class="headerlink" title="Second attempt"></a>Second attempt</h1><p>I was fixing this pattern issue, replacing it with <code>ARGUMENTS.length &lt;= INDEX ? undefined : ARGUMENTS[INDEX]</code>, when I noticed my previous patch was incomplete.</p>
<figure class="highlight js"><figcaption><span>actual.js</span><a href="https://github.com/babel/babel/blob/15969a09046a50ae2ae0503725b7fb00cdd7137f/packages/babel-plugin-transform-es2015-parameters/test/fixtures/parameters/rest-multiple/actual.js" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="function"><span class="keyword">function</span> (<span class="params">f, ...items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = f;</span><br><span class="line">    x = items[<span class="number">0</span>];</span><br><span class="line">    x = items[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>was still being converted to:</p>
<figure class="highlight js"><figcaption><span>expected.js</span><a href="https://github.com/babel/babel/blob/15969a09046a50ae2ae0503725b7fb00cdd7137f/packages/babel-plugin-transform-es2015-parameters/test/fixtures/parameters/rest-multiple/expected.js" target="_blank" rel="external">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = f;</span><br><span class="line">    x = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    x = <span class="built_in">arguments</span>[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The transform was not taking into account the presence of a rest parameter when there were other parameters involved (<code>function (f, ...items)</code>). After I fixed this issue, I had another one: <code>x = items[1]</code> was correctly transformed, but not <code>x[1] = ...</code>, <code>x.p = ...</code> or <code>... = items[1] || something</code>. I had to generalise the patch to (safely) cover all possible occurrences of accessing a value from a rest argument.</p>
<p>I added a fixture test, reworked my patch and opened a new PR: <a href="https://github.com/babel/babel/pull/3165" target="_blank" rel="external">Fixing T6818</a>.</p>
<figure class="highlight js"><figcaption><span>actual.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u</span>(<span class="params">f, g, ...items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = f;</span><br><span class="line">    <span class="keyword">var</span> y = g;</span><br><span class="line">    x[<span class="number">12</span>] = items[<span class="number">0</span>];</span><br><span class="line">    y.prop = items[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> z = items[<span class="number">2</span>] | <span class="number">0</span> || <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>expected.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = f;</span><br><span class="line">    <span class="keyword">var</span> y = g;</span><br><span class="line">    x[<span class="number">12</span>] = <span class="built_in">arguments</span>.length &lt;= <span class="number">2</span> ? <span class="literal">undefined</span> : <span class="built_in">arguments</span>[<span class="number">2</span>];</span><br><span class="line">    y.prop = <span class="built_in">arguments</span>.length &lt;= <span class="number">3</span> ? <span class="literal">undefined</span> : <span class="built_in">arguments</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">var</span> z = (<span class="built_in">arguments</span>.length &lt;= <span class="number">4</span> ? <span class="literal">undefined</span> : <span class="built_in">arguments</span>[<span class="number">4</span>]) | <span class="number">0</span> || <span class="number">12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hopefully, this part is done. I’ll try to find some other Crankshaft-related-JS-anti-patterns in what Babel generates.</p>
]]></content>
    <summary type="html">
    <![CDATA[How I increased Babel ES2015 performances with two simple patches and some research]]>
    
    </summary>
    
      <category term="babel" scheme="https://vhf.github.io/blog/tags/babel/"/>
    
      <category term="es2015" scheme="https://vhf.github.io/blog/tags/es2015/"/>
    
      <category term="javascript" scheme="https://vhf.github.io/blog/tags/javascript/"/>
    
      <category term="nodejs" scheme="https://vhf.github.io/blog/tags/nodejs/"/>
    
      <category term="programming" scheme="https://vhf.github.io/blog/categories/programming/"/>
    
      <category term="JavaScript" scheme="https://vhf.github.io/blog/categories/programming/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript performance with Babel and Node.js: a case against default parameters in tail call optimizations]]></title>
    <link href="https://vhf.github.io/blog/2015/11/02/javascript-performance-with-babel-and-node-js/"/>
    <id>https://vhf.github.io/blog/2015/11/02/javascript-performance-with-babel-and-node-js/</id>
    <published>2015-11-02T12:36:59.000Z</published>
    <updated>2015-12-17T13:15:09.000Z</updated>
    <content type="html"><![CDATA[<p>Disclaimer:</p>
<ul>
<li>Babel 5.8.29 (babel-core 5.8.33)</li>
<li>Node.js v5.0.0</li>
<li>I know these factorial examples are very artificial, please bear with me, I’ll explain how I came to look at those things at the end of this post</li>
<li>The title of this post might be incorrect (or too specific), I’ll also talk about it later</li>
<li>Optimization is not an obsession of mine. Having fun with JavaScript is.</li>
</ul>
<p>Here are three recursive implementations of the factorial function:</p>
<figure class="highlight js"><figcaption><span>tail-call.js</span><a href="https://gist.github.com/vhf/25eebd0aa0ca5b3c1aec#file-tail-call-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "naive"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * factorial1(x-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tail rec using a default parameter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec2(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec2</span>(<span class="params">x, acc = 1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> facRec2(x-<span class="number">1</span>, x*acc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tail rec</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec3(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec3</span>(<span class="params">x, acc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> facRec3(x-<span class="number">1</span>, x*acc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Which one do you think will perform better when transpiled into ES5, transformed by Babel’s tail call optimization (TCO for short), and run on Node.js (therefore V8)?</p>
<p>It would be reasonable to expect:</p>
<ul>
<li>#1 to be the slowest because there’s no tail call (therefore TCO does not happen)</li>
<li>#2 and #3 to perform better than #1 (because TCO)</li>
<li>#2 and #3 to be more or less equivalent in terms of performances</li>
</ul>
<p>Let’s <a href="https://github.com/bestiejs/benchmark.js" target="_blank" rel="external">benchmark</a> it (<a href="https://gist.github.com/vhf/ecd9dba814a4edd80680" target="_blank" rel="external">suite</a>): <code>babel tail-call.js &gt; tail-call-babel.js; node tail-call-babel.js</code></p>
<pre><code>#1 no tail call          x 1,562,075 ops/sec ±0.59% (98 runs sampled)
#2 TCO/default params    x   259,399 ops/sec ±0.92% (91 runs sampled)
#3 TCO/no default params x 7,046,389 ops/sec ±0.45% (101 runs sampled)
Fastest is #3 TCO/no default params
</code></pre><ul>
<li>#3 is 27x (!) better than #2</li>
<li>Even #1 significantly outperforms #2</li>
</ul>
<p>So my quest began. What could be so wrong about #2?</p>
<p>The obvious thing to do at this point was to look at Babel’s output:</p>
<figure class="highlight js"><figcaption><span>tail-call-babel.js</span><a href="https://gist.github.com/vhf/d9e9750ae25e9dee6190#file-tail-call-babel-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>;</span><br><span class="line"><span class="comment">// #1 "naive"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * factorial1(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #2 tail rec using a default parameter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec2(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec2</span>(<span class="params">_x2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> _again = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _function: <span class="keyword">while</span> (_again) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = _x2;</span><br><span class="line">    _again = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> acc = _arguments.length &lt;= <span class="number">1</span> || _arguments[<span class="number">1</span>] === <span class="literal">undefined</span> ? <span class="number">1</span> : _arguments[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _arguments = [_x2 = x - <span class="number">1</span>, x * acc];</span><br><span class="line">      _again = <span class="literal">true</span>;</span><br><span class="line">      acc = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">continue</span> _function;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// #3 tail rec</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> facRec3(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facRec3</span>(<span class="params">_x3, _x4</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _again2 = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  _function2: <span class="keyword">while</span> (_again2) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = _x3,</span><br><span class="line">        acc = _x4;</span><br><span class="line">    _again2 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> acc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _x3 = x - <span class="number">1</span>;</span><br><span class="line">      _x4 = x * acc;</span><br><span class="line">      _again2 = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span> _function2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>My first reflex was to check if TCO happened. Yes, and it did a fine job at transforming both tail recursive functions <code>facRec2</code> and <code>facRec3</code> into iterative functions. (If <code>factorial2</code> uses an iterative <code>facRec2</code>, why would <code>factorial1</code> and its still-recursive implementation perform better? It’s nice to know that <code>factorial2</code> won’t bark <code>RangeError: Maximum call stack size exceeded</code> at me, but at what cost?)</p>
<p>The next obvious thing to do was to consider the only single little difference between <code>facRec2</code> and <code>facRec3</code> in the original code: the use of an ES6 default parameter. A quick glance at Babel’s output made the use of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" target="_blank" rel="external"><code>arguments</code></a> stand out.</p>
<p>I remembered reading about <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers" target="_blank" rel="external">V8 “optimization killers”</a>, particularly a bit about <code>arguments</code>. Let me summarize the third section in the form of a checklist with regards to how the transformed <code>facRec2</code> makes use of parameters and <code>arguments</code>:</p>
<ul>
<li>[ ] Don’t reassign defined parameters while also mentioning <code>arguments</code> in the body of a function</li>
<li>[x] Don’t leak <code>arguments</code></li>
<li>[x] Don’t assign to <code>arguments</code></li>
<li>[x] Don’t use <code>arguments</code> directly without <code>.length</code> or <code>[]</code></li>
<li>[x] Don’t <code>arguments[i]</code> with <code>i</code> not an integer or <code>i &gt; arguments.length-1</code></li>
<li>[x] Don’t do anything else than <code>fn.apply(y, arguments)</code></li>
</ul>
<p>Notice how <code>facRec2</code> does <code>_x2 = x - 1</code> although <code>_x2</code> is a defined parameter <em>and</em> <code>arguments</code> is mentioned in the function body? It contradicts the first rule.</p>
<p>I turned to V8. Here again, the awesome bluebird wiki page was very helpful: its first section, <a href="https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#1-tooling" target="_blank" rel="external">tooling</a>, had been my reference for some time.</p>
<p>I added:</p>
<figure class="highlight js"><figcaption><span>tail-call-babel-v8.js</span><a href="https://gist.github.com/vhf/01c095e09accf72108a1#file-tail-call-babel-v8-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printStatus</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = fn.name;</span><br><span class="line">  <span class="keyword">switch</span>(%GetOptimizationStatus(fn)) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">console</span>.log(name, <span class="string">' is optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">console</span>.log(name, <span class="string">' is not optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">console</span>.log(name, <span class="string">' is always optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">console</span>.log(name, <span class="string">' is never optimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">console</span>.log(name, <span class="string">' is maybe deoptimized'</span>); <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial1(<span class="number">100</span>);</span><br><span class="line">factorial1(<span class="number">100</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(factorial1);</span><br><span class="line">factorial1(<span class="number">100</span>);</span><br><span class="line">printStatus(factorial1);</span><br><span class="line"></span><br><span class="line">facRec2(<span class="number">100</span>, <span class="number">1</span>); <span class="comment">// I should add that facRec2(100) leads to the same perf issue</span></span><br><span class="line">facRec2(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(facRec2);</span><br><span class="line">facRec2(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">printStatus(facRec2);</span><br><span class="line"></span><br><span class="line">facRec3(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">facRec3(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(facRec3);</span><br><span class="line">facRec3(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">printStatus(facRec3);</span><br></pre></td></tr></table></figure>
<p>at the end of <code>tail-call-babel.js</code> and ran the following:</p>
<pre><code>node --allow-natives-syntax tail-call-babel.js
  factorial1 is optimized
  facRec2 is not optimized
  facRec3 is optimized
</code></pre><p>It was clear that V8 — more precisely <a href="http://jayconrod.com/posts/54/a-tour-of-v8-crankshaft-the-optimizing-compiler" target="_blank" rel="external">Crankshaft</a> — was bailing out on <code>facRec2</code>.</p>
<p>I simply had to refactor <code>facRec2</code> to make it stop reassigning to <code>_x2</code>, right? Nope, <code>facRec2</code> still could not be optimized. Here’s a <a href="https://gist.github.com/vhf/5560a6502d5147a766f6" target="_blank" rel="external">gist</a>.</p>
<p>Going back to the checklist, I noticed that <code>facRec2</code> actually assigns to the <code>_arguments</code> object, which is a reference to <code>arguments</code>, which also contradicts something from the above checklist: Don’t assign to <code>arguments</code>.</p>
<p>Going back to the <code>facRec2</code> generated code, I copied it to create <code>facRec2b</code>, replacing <code>var _arguments = arguments;</code> with <code>var $_len = arguments.length; var _arguments = new Array($_len); for(var $_i = 0; $_i &lt; $_len; ++$_i) {_arguments[$_i] = arguments[$_i];}</code> (<a href="https://gist.github.com/vhf/58769c1d0462094a66a3" target="_blank" rel="external">full gist</a>). And V8 was happy: <code>facRec2b is optimized</code>.</p>
<p>New benchmark:</p>
<pre><code>#1 no tail call               x 1,562,300 ops/sec ±0.44% (98 runs sampled)
#2 TCO/default params + leak  x   256,521 ops/sec ±0.96% (95 runs sampled)
#2 TCO/default params no leak x   812,920 ops/sec ±0.83% (94 runs sampled)
#3 TCO/no default params      x 7,060,279 ops/sec ±0.49% (94 runs sampled)
</code></pre><p>When optimized by V8, <code>facRec2b</code> runs already 3x faster than its <code>facRec2</code> counterpart, but still ~2x slower than <code>factorial1</code>, and their performances cannot be matched with <code>facRec3</code>.</p>
<p>Here were my initial conclusions:</p>
<ul>
<li>assigning to <code>_arguments</code>, which references <code>arguments</code>, is what prevents V8 from optimizing <code>facRec2</code></li>
<li>safely converting <code>arguments</code> to an array fixes this issue</li>
<li>even with this fix, <code>facRec2b</code> is still so slow that we should simply decide not to use default parameters in any function susceptible to be TCOed by Babel</li>
<li>is there a better way to get V8 to optimize <code>facRec2</code>?</li>
<li>what’s up with this <em>Don’t reassign defined parameters while also mentioning <code>arguments</code> in the body of a function</em> rule? I thought <a href="https://gist.github.com/vhf/a884c556a70bdcf21fbc" target="_blank" rel="external">this</a> would trigger an <em>Assignment to parameter in arguments object</em> but I could not make it happen. Answer at the end of this post.</li>
</ul>
<p>Was there more to it?</p>
<p>I took a closer look:</p>
<pre><code>node --trace-opt --trace_deopt --allow-natives-syntax tail-call-babel.js | grep facRec2 | grep -v facRec2b
  [compiling method 0x11469d0922c1 &lt;JS Function facRec2 (SharedFunctionInfo 0x24a5614171a9)&gt; using Crankshaft]
  [aborted optimizing 0x11469d0922c1 &lt;JS Function facRec2 (SharedFunctionInfo 0x24a5614171a9)&gt; because: Unsupported phi use of arguments]
  [disabled optimization for 0x24a5614171a9 &lt;SharedFunctionInfo facRec2&gt;, reason: Unsupported phi use of arguments]
</code></pre><p>Unsupported phi use of arguments. At this point I should probably say that I don’t know much about V8 internals or source code. However, I was still determined to know what was wrong with <code>facRec2</code>, so I tried looking for this cryptic <code>Unsupported phi use of arguments</code> thing on Google (after all, they are the most qualified for this particular request).</p>
<p>It’s not every day that one of my search engine requests only returns 11 results. The most interesting one is probably <a href="https://codereview.chromium.org/7553006" target="_blank" rel="external">the very commit that introduced this bailout reason</a>. I took a quick glance at <code>HGraph::CheckPhis</code>: something about blocks?</p>
<p>I thought I would learn more trying to write a minimal program reproducing this bailout reason. But that was not an easy task. What I ended up with are these three functions:</p>
<figure class="highlight js"><figcaption><span>unsupported-phi-use-of-arguments.js</span><a href="https://gist.github.com/vhf/5f88c10e2a0680a4fb19#file-unsupported-phi-use-of-arguments-js" target="_blank" rel="external">gist</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> === <span class="number">0</span>) &#123; <span class="comment">// anything evaluating to true, except a number or `true`</span></span><br><span class="line">    _arguments = [<span class="number">0</span>]; <span class="comment">// Unsupported phi use of arguments</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    _arguments = [<span class="number">0</span>]; <span class="comment">// Unsupported phi use of arguments</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">phi3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">var</span> again = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (again) &#123;</span><br><span class="line">    _arguments = [<span class="number">0</span>]; <span class="comment">// Unsupported phi use of arguments</span></span><br><span class="line">    again = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HGraph::CheckPhis</code> started to make sense: reassigning <code>arguments</code> inside a “block” triggers <em>Unsupported phi use of arguments</em>. But assigning <em>to</em> <code>arguments</code> does not: it triggers a <em>Bad value context for arguments value</em>, which is already covered on <a href="http://bahmutov.calepin.co/detecting-function-optimizations-in-v8.html" target="_blank" rel="external">blogs</a> and <a href="http://stackoverflow.com/questions/29198195/whats-the-deal-with-optimising-arguments" target="_blank" rel="external">StackOverflow</a>.</p>
<h3 id="So_2C_what_u2019s_your_point_3F_Conclusion"><a href="#So_2C_what_u2019s_your_point_3F_Conclusion" class="headerlink" title="So, what’s your point? Conclusion."></a>So, what’s your point? Conclusion.</h3><p>I just wanted to practice my storytelling. And also, I wanted to raise this question: what can we do about this whole default-parameter-TCO-V8-thing? I’m not sure, so here are a few questions I would like to ask you:</p>
<ul>
<li>Should we just avoid using default parameters in any function susceptible to be TCOed by Babel? (in this example, x27 on V8)</li>
<li>or make Babel safely create an array from <code>arguments</code> in such cases? (x3)</li>
<li>or at least mention this thing in Babel’s doc as soon as Babel 6 unblacklists <code>es6.tailCall</code>? (If this ever happens? If you have informations about this blacklisting, I’d love to know!)</li>
</ul>
<p><strong>I’d love to get your opinion on these questions!</strong></p>
<p>In a very interesting <a href="https://devchat.tv/js-jabber/171-jsj-babel-with-sebastian-mckenzie" target="_blank" rel="external">recent podcast</a> ([<a href="http://devchat.cachefly.net/javascriptjabber/transcript-171-jsj-babel-with-sebastian-mckenzie-js-jabber.pdf" target="_blank" rel="external">transcript</a>]), Babel’s author Sebastian McKenzie said several things about Babel’s performances, and how outputting more performant code impacts its readability, and how that’s ok because the focus is on performance: “would you care more about your code being pretty or your code being as fast as possible?”, and I agree, it is certainly more important for Babel to be fast than readable.</p>
<p>But he also said the following: “But now it’s just like you really shouldn’t be reading your compiled code anyway.” I have to disagree. In fact, if you indeed care about performances, you most probably <em>should</em> be reading your compiled code. (Now, don’t get met wrong: I think Babel is an awesome piece of software and I love it and I use it everywhere and Sebastian McKenzie et al. are doing a terrific job, and if you think this post is bashing Babel you’re just plain wrong. This disclaimer is probably useless, but I’m new to blogging and it’s kind of scary.)</p>
<p>I would love Babel to improve on this specific point; I can’t promise anything but I’ll try to hack on it. And if it gets me somewhere, I’ll try to write it up. My storytelling needs practice.</p>
<h4 id="Unsupported_phi_use_of_arguments"><a href="#Unsupported_phi_use_of_arguments" class="headerlink" title="Unsupported phi use of arguments"></a>Unsupported phi use of arguments</h4><p>Unsatisfied of my poor understanding of this Crankshaft bailout message I reached out to <a href="http://mrale.ph" target="_blank" rel="external">Vyacheslav Egorov</a>, who first introduced it and promptly clarified he did not add the bailout itself.</p>
<p>I asked him what does <code>blocks_</code> contain in the <code>HGraph::CheckPhis</code> function I mentioned earlier:</p>
<blockquote>
<p>Blocks will contain CFG (control flow graph) blocks — these are not blocks in the syntactical sense, e.g. <code>x ? y : z</code> is not a block in JavaScript but will be 4 blocks in the CFG — once optimizing compiler gets to it.</p>
</blockquote>
<p>What’s up with this <em>Don’t reassign defined parameters while also mentioning <code>arguments</code> in the body of a function</em> rule? Why does <a href="https://gist.github.com/vhf/a884c556a70bdcf21fbc" target="_blank" rel="external">this code</a> not trigger a bailout?</p>
<blockquote>
<p>This limitation is still there — but it does not apply to strict functions. I think you somehow run your code in strict mode that’s why you don’t see a bailout.</p>
</blockquote>
<p>Indeed, I ran my tests in strict mode.</p>
<p>Regarding the second point of my conclusion, he said:</p>
<blockquote>
<p>Allocating array (and hope it will get handled by some optimization pass in the V8) is a bad idea.</p>
</blockquote>
<p>Thanks to Vyacheslav, this bailout message starts to make sense to me. He could have only answered the few questions I sent him by email. Instead, he was kind enough to answer them, read a draft of this blog post, and even went on to write a thorough and clear explaination of <em>Unsupported phi use of arguments</em> on his blog: <a href="http://mrale.ph/blog/2015/11/02/crankshaft-vs-arguments-object.html" target="_blank" rel="external">Crankshaft vs arguments object</a> — which I still need to digest.</p>
<h4 id="A_few_side_notes"><a href="#A_few_side_notes" class="headerlink" title="A few side notes"></a>A few side notes</h4><ul>
<li><a href="https://github.com/babel/babel/tree/v5.8.33/packages/babel/test/fixtures/transformation/es6.tail-call/recursion" target="_blank" rel="external">es6.tailCall recursion test case including default parameter</a>: Interesting test case with regards to V8 optimization: first because <code>_x2</code> (a defined parameter) gets reassigned which triggers <em>Assignment to parameter in arguments object</em> bailout reason, secondly because if we <code>var __x2 = _x2</code> and don’t reassign <code>_x2</code> we get the infamous <em>Unsupported phi use of arguments</em>.</li>
<li>Why the title of this post might be too specific: I have not investigated (yet?) whether <em>Unsupported phi use of arguments</em> is only triggered by Babel generated ES5 in the specific <em>TCO + default parameter</em> case or is also present in other Babel generated ES5 <em>default parameter</em> cases.</li>
<li>Why these artifical examples: because they are short and easy to reason about. Also, cf. the following point:</li>
<li>How did you come up with this thing? One of might projects depends on underscore, which does not have an equivalent of <a href="https://lodash.com/docs#get" target="_blank" rel="external"><code>get</code></a>. So I quickly drafted the tail rec <code>_.get</code> I was dreaming of, then googled for a bit and found John-David Dalton’s <a href="https://github.com/jashkenas/underscore/issues/2268#issuecomment-128731431" target="_blank" rel="external"><code>_.reduce(path, _.partial(_.result, _, _, void 0), object)</code></a> (which felt like too much black magic for me). But me being curious and it being a cold evening, I benchmarked both solutions. And mine was awfully slow. So I asked V8 about it, discovered the <em>phi</em> thing, reimplemented my recursive <code>get</code> without its default parameter, ran the benchmark again and got this: <code>TCO 676,411(±0.43%) | 674,426(±0.49%) JDD</code>. So, basically the same performances. Underscore never fails to impress me! Which led to two things: 1/ I kept my nice recursive <code>get</code> because it’s more readable, 2/ I spent my weekend researching+writing this blog post.</li>
<li>I know I should probably not rely on this benchmark package and should do cpu profiling instead, and that it’s easy to do with V8, etc. I think the timing differences shown here are big enough to decide that for this particular post, benchmark is good enough. But I’ll do better next time.</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Babel might prevent some V8 optimizations to happen. Also, have you heard about Unsupported Phi Use of Arguments?]]>
    
    </summary>
    
      <category term="babel" scheme="https://vhf.github.io/blog/tags/babel/"/>
    
      <category term="es2015" scheme="https://vhf.github.io/blog/tags/es2015/"/>
    
      <category term="javascript" scheme="https://vhf.github.io/blog/tags/javascript/"/>
    
      <category term="nodejs" scheme="https://vhf.github.io/blog/tags/nodejs/"/>
    
      <category term="programming" scheme="https://vhf.github.io/blog/categories/programming/"/>
    
      <category term="JavaScript" scheme="https://vhf.github.io/blog/categories/programming/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 Destructuring]]></title>
    <link href="https://vhf.github.io/blog/2015/10/28/es6-destructuring/"/>
    <id>https://vhf.github.io/blog/2015/10/28/es6-destructuring/</id>
    <published>2015-10-28T14:29:42.000Z</published>
    <updated>2015-12-17T14:57:20.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>Destructuring works exactly as its syntax suggests</li>
<li>The only tricky point is object destructuring without variable declaration<ul>
<li>with declaration: <code>let {x: a} = {x: &#39;a&#39;};</code></li>
<li>without declaration: <code>({x: a} = {x: &#39;a&#39;});</code> (assuming that <code>a</code> has already been declared)</li>
<li>It’s simply because <a href="http://stackoverflow.com/questions/17382024/why-is-a-bare-array-valid-javascript-syntax-but-not-a-bare-object" target="_blank" rel="external">a bare object is not valid syntax</a></li>
</ul>
</li>
<li>Default arguments and destructuring:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* prop === 'default' */</span> <span class="keyword">let</span> &#123; prop = <span class="string">'default'</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="comment">/* prop === 'value' */</span>   <span class="keyword">let</span> &#123; prop = <span class="string">'default'</span> &#125; = &#123; prop: <span class="string">'value'</span> &#125;;</span><br><span class="line"><span class="comment">/* name === 'value' */</span>   <span class="keyword">let</span> &#123; prop: name = <span class="string">'default'</span> &#125; = &#123; prop: <span class="string">'value'</span> &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Default arguments also work for arrays:<ul>
<li><code>let [head = &quot;default&quot;] = [];</code></li>
</ul>
</li>
<li>Default values for destructuring assignment is especially useful as function arguments defaults:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> destructObject = (&#123; a = <span class="string">'a'</span>, b = <span class="string">'b'</span> &#125; = &#123;&#125;) =&gt; [a, b];</span><br><span class="line"><span class="keyword">let</span> destructObject = (&#123; a: arg1 = <span class="string">'a'</span>, b: arg2 = <span class="string">'b'</span> &#125; = &#123;&#125;) =&gt; [arg1, arg2];</span><br><span class="line">destructObject(&#123;&#125;);       <span class="comment">// ['a', 'b]</span></span><br><span class="line">destructObject(&#123; b: <span class="string">'c'</span> &#125;); <span class="comment">// ['a', 'c']</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[destructuring and assigning default values]]>
    
    </summary>
    
      <category term="es2015" scheme="https://vhf.github.io/blog/tags/es2015/"/>
    
      <category term="javascript" scheme="https://vhf.github.io/blog/tags/javascript/"/>
    
      <category term="programming" scheme="https://vhf.github.io/blog/categories/programming/"/>
    
      <category term="JavaScript" scheme="https://vhf.github.io/blog/categories/programming/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Promises]]></title>
    <link href="https://vhf.github.io/blog/2015/10/27/javascript-promises/"/>
    <id>https://vhf.github.io/blog/2015/10/27/javascript-promises/</id>
    <published>2015-10-27T18:37:41.000Z</published>
    <updated>2015-12-17T13:15:02.000Z</updated>
    <content type="html"><![CDATA[<p>I read <a href="https://60devs.com/best-practices-for-using-promises-in-js.html" target="_blank" rel="external">Best Practices for Using Promises in JS</a>. Here are some concise notes expanding on this topic.</p>
<ul>
<li>Let’s use bluebird as Promise implementation for node</li>
<li>Use <code>.then().catch()</code> instead of <code>.then(successCb, failCb)</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = (shouldResolve) =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (shouldResolve) &#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject();</span><br><span class="line">  &#125;&#125;);</span><br><span class="line"></span><br><span class="line">promise(arg)</span><br><span class="line">  .then(() =&gt; &#123; <span class="comment">/* success */</span> &#125;)</span><br><span class="line">  .catch(ExceptionToCatch, OtherExceptionToCatch, (err) =&gt; &#123; <span class="comment">/* error */</span>&#125;)</span><br><span class="line">  .catch(StrangeExceptionToCatch, (err) =&gt; &#123; <span class="comment">/* error */</span>&#125;)</span><br><span class="line">  .catch((err) =&gt; &#123; <span class="comment">/* error */</span>&#125;); <span class="comment">// default</span></span><br></pre></td></tr></table></figure>
<p>To define an exception to catch:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyCustomError</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">MyCustomError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line"></span><br><span class="line">promise(arg)</span><br><span class="line">  .then(() =&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> MyCustomError() &#125;)</span><br><span class="line">  .catch(MyCustomError, (err) =&gt; &#123;&#125;)</span><br><span class="line">  .catch((err) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Promise.all([promiseA(a), promiseB(b)])</code> runs two async functions in parallel, but <code>.then(() =&gt; {})</code> callback has no data result argument</li>
<li>Use <code>.spread</code> instead of <code>.then</code> to get this data: <code>.spread((dataA, dataB) =&gt; {})</code></li>
<li>To limit concurrency, <code>Promise.map([lotsOfStuff], promise, { concurrency: 3 }).then(() =&gt; {})</code></li>
<li>See also <code>.reduce</code> and <code>.filter</code></li>
<li>You can “pipe” your <code>.then</code> functions. If you do this, you should probably avoid using anonymous functions and enjoy more reusability, modularity, testability, readability</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readFile(data)</span><br><span class="line">  .then(<span class="built_in">JSON</span>.parse)</span><br><span class="line">  .then(treatStuff)</span><br><span class="line">  .catch(handleError)</span><br></pre></td></tr></table></figure>
<ul>
<li>Don’t abuse this thing. It’s nice to read, but it breaks the event loop and could introduce race conditions</li>
<li>A better approach is to pipe inside the <code>.then</code>:</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readFile(data)</span><br><span class="line">  .then(pipe(<span class="built_in">JSON</span>.parse, treatStuff))</span><br><span class="line">  .catch(handleError)</span><br></pre></td></tr></table></figure>
<h2 id="Further_reading_3A"><a href="#Further_reading_3A" class="headerlink" title="Further reading:"></a>Further reading:</h2><ul>
<li><a href="http://bluebirdjs.com" target="_blank" rel="external">http://bluebirdjs.com</a></li>
<li><a href="https://promise-nuggets.github.io" target="_blank" rel="external">https://promise-nuggets.github.io</a></li>
<li><a href="http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html" target="_blank" rel="external">http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</a></li>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md" target="_blank" rel="external">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[promises, bluebird, etc]]>
    
    </summary>
    
      <category term="es2015" scheme="https://vhf.github.io/blog/tags/es2015/"/>
    
      <category term="javascript" scheme="https://vhf.github.io/blog/tags/javascript/"/>
    
      <category term="nodejs" scheme="https://vhf.github.io/blog/tags/nodejs/"/>
    
      <category term="promises" scheme="https://vhf.github.io/blog/tags/promises/"/>
    
      <category term="programming" scheme="https://vhf.github.io/blog/categories/programming/"/>
    
      <category term="JavaScript" scheme="https://vhf.github.io/blog/categories/programming/JavaScript/"/>
    
  </entry>
  
</feed>
